=================================================
Project : math_35	start : 17/07/20 16:04
org.apache.commons.math3.genetics.ElitisticListPopulation,51
----------------------------------------
Pass Single Test :
super(chromosomes,populationLimit);
if(elitismRate<0||elitismRate>1){
throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE,elitismRate,0,1);
}
this.elitismRate=elitismRate;

----------------------------------------

Successfully find a patch!
Failed time : 17/07/20 16:06
=================================================
Project : math_70	start : 17/07/20 16:06
org.apache.commons.math.analysis.solvers.BisectionSolver,72
----------------------------------------
Pass Single Test :
return solve(f,min,max);

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
return solve(f,min,max);

----------------------------------------

Successfully find a patch!
Failed time : 17/07/20 16:08
=================================================
Project : math_33	start : 17/07/20 16:08
org.apache.commons.math3.optimization.linear.SimplexTableau,338
----------------------------------------
Pass Single Test :
if(Precision.compareTo(entry,0.0,epsilon)>0){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
if(Precision.compareTo(entry,0.0,epsilon)>0){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(Precision.compareTo(entry,epsilon,maxUlps)>0){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
if(Precision.compareTo(entry,epsilon,maxUlps)>0){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(Precision.compareTo(entry,0.0,maxUlps)>maxUlps){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(Precision.compareTo(entry,0.0,maxUlps)>=maxUlps){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(Precision.compareTo(entry,0.0,maxUlps)>1){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(Precision.compareTo(entry,0.0,maxUlps)>this.numArtificialVariables){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if((i&1)==0){
continue;
}
if(Precision.compareTo(entry,0.0,maxUlps)>0){
columnsToDrop.add(i);
}

----------------------------------------

Successfully find a patch!
Failed time : 17/07/20 16:25
=================================================
Project : math_5	start : 17/07/20 16:25
org.apache.commons.math3.complex.Complex,304
----------------------------------------
Pass Single Test :
if(real==0.0&&imaginary==0.0){
return INF;
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
if(real==0.0&&imaginary==0.0){
return INF;
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(real==0.0||imaginary==0.0){
return INF;
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(Double.isInfinite(real)||imaginary==0.0){
return INF;
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(real==0.0||Double.isInfinite(imaginary)){
return INF;
}

----------------------------------------

Successfully find a patch!
Failed time : 17/07/20 16:43
=================================================
Project : math_53	start : 17/07/20 16:43
org.apache.commons.math.complex.Complex,153
----------------------------------------
Pass Single Test :
MathUtils.checkNotNull(rhs);
if(isNaN||rhs.isNaN){
return NaN;
}
return createComplex(real+rhs.getReal(),imaginary+rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
MathUtils.checkNotNull(rhs);
if(isNaN||rhs.isNaN){
return NaN;
}
return createComplex(real+rhs.getReal(),imaginary+rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
MathUtils.checkNotNull(rhs);
if(isNaN||rhs.isNaN){
return NaN;
}
return createComplex(real-rhs.getReal(),imaginary+rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
MathUtils.checkNotNull(rhs);
if(isNaN||rhs.isNaN){
return NaN;
}
return createComplex(real+rhs.getReal(),imaginary-rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
MathUtils.checkNotNull(rhs);
if(isNaN||rhs.isNaN){
return NaN;
}
return createComplex(real-rhs.getReal(),imaginary-rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
if(isNaN||rhs.isNaN){
return NaN;
}
MathUtils.checkNotNull(rhs);
return createComplex(real+rhs.getReal(),imaginary+rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
if(isNaN||rhs.isNaN){
return NaN;
}
MathUtils.checkNotNull(rhs);
return createComplex(real+rhs.getReal(),imaginary+rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
MathUtils.checkNotNull(rhs);
return createComplex(real*rhs.real-imaginary*rhs.imaginary,imaginary+rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
MathUtils.checkNotNull(rhs);
return createComplex(real*rhs.real-imaginary*rhs.imaginary,real*rhs.imaginary+imaginary*rhs.real);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
MathUtils.checkNotNull(rhs);
if(Double.isInfinite(real)||Double.isInfinite(imaginary)){
return INF;
}
return createComplex(real*rhs.real-imaginary*rhs.imaginary,imaginary+rhs.getImaginary());

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
MathUtils.checkNotNull(rhs);
if(Double.isInfinite(real)||Double.isInfinite(imaginary)){
return INF;
}
return createComplex(real*rhs.real-imaginary*rhs.imaginary,real*rhs.imaginary+imaginary*rhs.real);

----------------------------------------

Successfully find a patch!
Failed time : 17/07/20 17:03
=================================================
Project : math_59	start : 17/07/20 17:03
org.apache.commons.math.util.FastMath,3482Failed time : 17/07/20 17:04
=================================================
Project : math_79	start : 17/07/20 17:04
org.apache.commons.math.util.MathUtils,1624
----------------------------------------
Pass Single Test :
int sum=0;
for(int i=NAN_GAP;i<p1.length;i++){
 final int dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
int sum=0;
for(int i=0;i<p1.length;i++){
 final double dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
int sum=0;
for(int i=0;i<p1.length;i++){
 final double dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
int sum=0;
for(int i=0;i<p1.length;i++){
 final int dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(0);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
int sum=0;
for(int i=4;i<p1.length;i++){
 final int dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
int sum=0;
for(int i=9;i<p1.length;i++){
 final int dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
int sum=0;
for(int i=4;i<p1.length;i++){
if(100*SAFE_MIN<SAFE_MIN){
break;
}
 final int dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
int sum=0;
for(int i=9;i<p1.length;i++){
if(100*SAFE_MIN<SAFE_MIN){
break;
}
 final int dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
int sum=0;
for(int i=10;i<p1.length;i++){
 final int dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
int sum=0;
for(int i=10;i<p1.length;i++){
if(100*Math.max(SAFE_MIN,SAFE_MIN)<SAFE_MIN){
break;
}
 final int dp=p1[i]-p2[i];
sum+=dp*dp;
}
return Math.sqrt(sum);

----------------------------------------

Successfully find a patch!
Failed time : 17/07/20 17:17
=================================================
Project : math_41	start : 17/07/20 17:17
org.apache.commons.math.stat.descriptive.moment.Variance,520
----------------------------------------
Pass Single Test :
for(int i=begin;i<begin+length;i++){
sumWts+=weights[i];
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
for(int i=begin;i<begin+length;i++){
sumWts+=weights[i];
}

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
for(int i=begin;i<begin;i++){
sumWts+=weights[i];
}

----------------------------------------

Successfully find a patch!
Failed time : 17/07/20 17:25
=================================================
Project : math_63	start : 17/07/20 17:25
org.apache.commons.math.util.MathUtils,417
----------------------------------------
Pass Single Test :
if(Double.isNaN(y)){
return false;
}
return (Double.isNaN(x)&&Double.isNaN(y))||x==y;

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
if(Double.isNaN(y)){
return false;
}
return (Double.isNaN(x)&&Double.isNaN(y))||x==y;

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
return equals(x,y,1)||x==y;

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
return equals(x,y,1)||x==y;

----------------------------------------

Successfully find a patch!

----------------------------------------
Pass Single Test :
return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN;

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN;

----------------------------------------

Successfully find a patch!
Success time : 17/07/20 17:32
=================================================
Project : math_75	start : 17/07/20 17:32
org.apache.commons.math.stat.Frequency,303
----------------------------------------
Pass Single Test :
return getPct((Comparable<?>)v);

----------------------------------------

Successfully find a patch!

----------------------------------------
Find a patch :
return getPct((Comparable<?>)v);

----------------------------------------

Successfully find a patch!
Failed time : 17/07/20 17:34
=================================================
Project : closure_57	start : 17/07/20 17:34
com.google.javascript.jscomp.ClosureCodingConvention,197